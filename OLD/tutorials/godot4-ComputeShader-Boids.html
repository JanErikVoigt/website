<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>janerikvoigt.de</title>

    <meta name="description" content="My Website">
    <meta name="author" content="Jan-Erik Voigt">

    <link rel="icon" href="content/icon1.png">
    <!--<link rel="stylesheet" href="mybulma/css/mystyles.css">-->
    <link rel="stylesheet" href="../css/mystyles.css">
    <link rel="stylesheet" href="../css/images.css">
    <!--<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.8.0/css/bulma.min.css">-->
    <script src="https://unpkg.com/ionicons@5.1.2/dist/ionicons.js"></script>

    <!-- syntax highlighting:-->
    <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/default.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

  </head>
  <body>

    <section class="hero is-primary">
      <div class="hero-body">
        <p class="title">
          janerikvoigt.de
        </p>
        <p class="subtitle">
          Projects
        </p>
      </div>
    </section>
    <section class="section">
      <div class="container">
        <h1 class="title">
          Boids in godot4-alpha with compute shaders
        </h1>
        <p class="subtitle">
          At the moment, this is <strong>still unfinished</strong> and probably not useful for you... sorry 
        </p>
    </div>
    </section>

    <section class="section">
      <div class="columns">
        <div class="column is-three-fifths is-offset-one-fifth">
          <div class="container">
            
          </div>
        </div>
      </div>
    </section>


    <section class="section">
        <div class="container">
            <div class="content">
            <h2>The gdscript to evaluate the compute-shader</h2>
            <p> this script should be the script of the <strong> parent of a MultmeshInstance</strong> named 'MultmeshInstance3D'.</p>

                <div class="highlight">
                    <pre><code>var rd : RenderingDevice
var shader : RID

func _ready():
    # Create a local rendering device.
    rd = RenderingServer.create_local_rendering_device()

    # Load GLSL shader
    var shader_file := load("res://compute_shader.glsl")
    var shader_spirv: RDShaderSPIRV = shader_file.get_spirv()
    shader = rd.shader_create_from_spirv(shader_spirv)

    # ...

func _process(delta):
    var inputDataArray : PackedFloat32Array = myMultiMesh.multimesh.buffer #put in own data here
    var input_bytes := inputDataArray.to_byte_array()


    # Create a storage buffer that can hold all values. Each
    # double has 8 byte (64 bit) so for 10 vals: 10 x 8 = 80 bytes
    # in this case I use floats, which have 4 bytes (32 bit)
    var bytesNeededForBuffer = 4 * inputDataArray.size()
    var buffer := rd.storage_buffer_create(bytesNeededForBuffer, input_bytes)
    var uniform := RDUniform.new()
    uniform.uniform_type = RenderingDevice.UNIFORM_TYPE_STORAGE_BUFFER
    uniform.binding = 0
    uniform.add_id(buffer)
    var uniform_set := rd.uniform_set_create([uniform], shader, 0)

    # Create a compute pipeline
    var pipeline := rd.compute_pipeline_create(shader)
    var compute_list := rd.compute_list_begin()
    rd.compute_list_bind_compute_pipeline(compute_list, pipeline)
    rd.compute_list_bind_uniform_set(compute_list, uniform_set, 0)
    rd.compute_list_dispatch(compute_list, 5, 1, 1)
    rd.compute_list_end()

    # Submit to GPU and wait for sync
    rd.submit()
    rd.sync()

    #rd.free() apparently, you are supposed to do this, but it only makes sense, if you use the rd once...

    # Read back the data from the buffers
    var output_bytes := rd.buffer_get_data(buffer)
    var output := output_bytes.to_float32_array()


</code></pre></div>


<h2>The GLSL-Computeshader</h2>


                <div class="highlight">
                    <pre><code>#[compute]

#version 450


//parameters 
float turnfactor = 0.2; // not needed?
float visualRange = 7.0;
float protectedRange = 0.7;
float centeringfactor = 0.007;
float avoidfactor = 0.008;
float matchingfactor = 0.9;
float maxspeed = 2.5;
float minspeed = 2;
float minSpeedChange = 0.0;
float maxSpeedChange = 0.5;

//TODO uints?

layout(local_size_x = 4) in;

layout(set = 0, binding = 0, std430) restrict buffer MyBuffer {
  float data[];
}
my_buffer;


vec3 getInstancePosition(int i) {
	return vec3(my_buffer.data[i * 16 + 3],my_buffer.data[i * 16 + 7],my_buffer.data[i * 16 + 11]);
}

vec3 getInstanceVelocity(int i) {
	return vec3(my_buffer.data[i * 16 + 12],my_buffer.data[i * 16 + 13],my_buffer.data[i * 16 + 14]);
}

void setInstancePosition(int i, vec3 pos) {
	my_buffer.data[i * 16 + 3] = pos.x;
	my_buffer.data[i * 16 + 7] = pos.y;
	my_buffer.data[i * 16 + 11] = pos.z;
}

void setInstanceVelocity(int i, vec3 vel) {
	my_buffer.data[i * 16 + 12] = vel.x;
	my_buffer.data[i * 16 + 13] = vel.y;
	my_buffer.data[i * 16 + 14] = vel.z;
}
float getInstancePanic(int i) {
	return my_buffer.data[i * 16 + 15];
}
float getDistSq(vec3 a, vec3 b) {
	return pow(a.x-b.x,2) + pow(a.y-b.y,2) +pow(a.z-b.z,2);
}


mat4 rotation3d(vec3 axis, float angle) {
  axis = normalize(axis);
  float s = sin(angle);
  float c = cos(angle);
  float oc = 1.0 - c;

  return mat4(
		oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
		0.0,                                0.0,                                0.0,                                1.0
	);
}
mat4 makeRotationDir(vec3 direction, vec3 up) {
        vec3 xaxis = normalize(cross(up, direction));
	vec3 yaxis = normalize(cross(up, xaxis));

	mat4 result;

        result[0] = vec4(xaxis.x, yaxis.x, direction.x, 0);
        result[1] = vec4(xaxis.y, yaxis.y, direction.y, 0);
        result[2] = vec4(xaxis.z, yaxis.z, direction.z, 0);
        result[3] = vec4(0, 0, 0, 1);
        
        return result;
}

mat4 lookAtMatrix(vec3 eye, vec3 center, vec3 up) {
	mat4 result = mat4(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	vec3 X;vec3 Y; vec3 Z;

	//Create a new coordinate system:

	Z = normalize(eye - center);
	Y = up;
	X = cross(Y,Z);

	//Recompute Y = Z cross X:
	
    	Y = cross(Z,X);

	//The length of the cross product is equal to the area of the parallelogram, which is < 1.0 for non-perpendicular unit-length vectors; so normalize X, Y here:

	X = normalize(X);
	Y = normalize(Y);

	//Put everything into the resulting 4x4 matrix:

	result[0][0] = X.x;
	result[1][0] = X.y;
	result[2][0] = X.z;
	result[3][0] = -dot(X,eye);
	result[0][1] = Y.x;
	result[1][1] = Y.y;
	result[2][1] = Y.z;
	result[3][1] = -dot(Y,eye);
	result[0][2] = Z.x;
	result[1][2] = Z.y;
	result[2][2] = Z.z;
	result[3][2] = -dot(Z, eye);
	result[0][3] = 0;
	result[1][3] = 0;
	result[2][3] = 0;
	result[3][3] = 1.0;

	return result;
}



void setInstanceTransform(int i, mat4 tra) {
	for(int o = 0; o < 12; o++) {
		my_buffer.data[i * 16 + o] = tra[o%4][o/4];
	}
}


void main() { //in place
	
	float delta = 0.4; //TODO get real delta?	
	
	//find out amount of instances:
	const int instance_count = my_buffer.data.length(); //TODO const?
	

	// for every boid do:
	for(int i = 0; i < instance_count; i++) {
		
		// calculate vel-changes from all 3 rules:
		vec3 vel1 = vec3(0,0,0); // coherence
		vec3 vel2 = vec3(0,0,0); // alignment
		vec3 vel3 = vec3(0,0,0); // seperation
		vec3 vel4 = vec3(0,0,0); // TODO target following
		
		// average pos and vel:
		int amountVisibleInstances = 0; //TODO unsigned?
		vec3 summedPos = vec3(0,0,0);
		vec3 summedVel = vec3(0,0,0);
		
		
		for(int j = 0; j < instance_count; j++) {
			if (j != i) {
				float distanceSq = getDistSq(getInstancePosition(i),getInstancePosition(j));
				if (distanceSq <= pow(visualRange,2)) { //TODO store visaulDistSq
					// instance is nearby:
					summedPos += getInstancePosition(j);
					summedVel += getInstanceVelocity(j);
					amountVisibleInstances++;
					
					
					if (distanceSq <= pow(protectedRange,2)) { //TODO store visaulDistSq
						//also within protected range:
						vel3 += (getInstancePosition(i) - getInstancePosition(j));// * avoidfactor;
						//todo too much? divide by amount of nearbies?
					}
				}
			}
		}
		
		if (amountVisibleInstances > 0) {
			vec3 averagePos = summedPos / amountVisibleInstances;
			vec3 averageVel = summedVel / amountVisibleInstances;
			
			vel1 = (averagePos-getInstancePosition(i)) * centeringfactor;
			vel2 = averageVel * matchingfactor;
		}
		
		/*
		# 4. Gravitate to target:
		var directionToTarget = swarmTarget.transform.origin-myPosition
		var distToTarget = directionToTarget.length()
		var speedToTarget = max(0,distToTarget-5) * targetfactor
		vel4 = directionToTarget.normalized() * speedToTarget
		*/
		
		vec3 totalVelChange = vel1 + vel2 + vel3 + vel4;
		float lenOfChange = length(totalVelChange);
		totalVelChange = normalize(totalVelChange) * clamp(lenOfChange, minSpeedChange*delta, maxSpeedChange*delta);
		
		vec3 newTotalVel = getInstanceVelocity(i) + totalVelChange;
		float speed = length(newTotalVel);
		newTotalVel = normalize(newTotalVel) * clamp(speed, minspeed*delta, maxspeed*delta);
		
		setInstanceVelocity(i,newTotalVel);
		
		// update looking Angle:
		//vec3 axis = cross(newTotalVel, vec3(0,1,0)); //UP
		//float angle = acos(dot(newTotalVel,vec3(0,0,1)));
		//mat4 tra = rotation3d(axis, angle);
		
		//mat4 tra = makeRotationDir(vec3(0,1,0), vec3(0,1,0));
		mat4 tra1 = mat4(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);
		tra1[3][0] = getInstancePosition(i).x; //todo make more beatuful
		tra1[3][1] = getInstancePosition(i).y;
		tra1[3][2] = getInstancePosition(i).z;
		tra1[3][3] = 1;
		mat4 tra = lookAtMatrix(getInstancePosition(i)+newTotalVel,getInstancePosition(i),vec3(0,1,0)); //TODO
		/*tra[3][0] += getInstancePosition(i).x; //todo make more beatuful
		tra[3][1] += getInstancePosition(i).y;
		tra[3][2] += getInstancePosition(i).z;*/
		
		
		setInstanceTransform(i,tra);
	}
}
</code></pre></div>


            </div>
        </div>

    </section>


</body>
</html>
